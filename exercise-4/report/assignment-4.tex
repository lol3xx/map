\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\headsep1cm
\parindent0cm
\usepackage{amssymb, amstext, amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{graphicx}

\lhead{\textbf{Electronic Market - 2APL Implementation}}
\rhead{(Submission: 11.04.2013)}

\cfoot{}
\lfoot{Robert Schmidtke - F121550, Marco Eilers - F121763}
\rfoot{\thepage\ of \pageref{LastPage}}
\pagestyle{fancy}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parskip}{4pt}

\begin{document}

\title{Multi-Agent Programming\\Assignment 4: Electronic Market - Jason Implementation}
\author{Robert Schmidtke - F121550, Marco Eilers - F121763}

\maketitle
\newpage

\section{Translation of Design into Implementation}
As in the previous assignment, we mostly referred to the GAIA model for the overall architecture of our solution, and to the Prometheus model for the details, since that is where the focus of the respective design methodologies is. All major components from our GAIA and Prometheus designs could be translated one to one to equivalent structures in 2APL. Like in the design, our 2APL implementation has two kinds of agents, the matchmaker and a number of traders. The environment contains a database which saves offers and requests, as specified in our GAIA model, and the negotiation works mostly the way we designed it in our Prometheus design.

\subsection{Data Structures}
The backing Java structures (\texttt{ItemDB} and \texttt{ItemDescriptor}) could be reused from the Jade assignment almost entirely, that is we only switched from describing items as a set of key-value-pairs of attributes to simply a list of attributes because this could easily be represented in 2APL using lists. This also reduced the complexity of the configuration files and finding buyers and sellers for matching items in the \texttt{ItemDB}. Since pattern matching using the complete list of attributes for an item is performed, the UUID for each item descriptor was not necessary anymore to uniquely identify an item that is being negotiated. Furthermore, we adapted the conversion mechanisms to and from \texttt{APLList}s when passing items to and from the environment.

The \texttt{ItemDB} is the only part of a custom environment, \texttt{ElectronicMarketEnv}. The environment is used only by the matchmaker agent by means of non-internal actions. The matchmaker itself only mitigates between trader agents and the \texttt{ItemDB}.

Since there is no way of defining a common agent Java base class that would be able to parse initial requests and offers and add them to the goal base of each trading agent we used the possibility of including beliefs with each agent in the \texttt{.mas} file by means of \texttt{<beliefs ... />} tags. These initial beliefs are then added as buy-/sell-goals by the initial goal \texttt{addGoals}. Note that we shipped the same set of offers and requests as in the previous exercise.

\subsection{Ease of Implementation}
Figuring out the correct way to implement the environmental class was a little more complicated than in the previous assignments because the manual is only very vague in what class/interface should be extended/implemented. The documentation of the EIS was more helpful in this case, but we ended up disassembling the \texttt{blockworld.jar} example file (because of missing sources) and analyzed the byte code to find out what class should be used as a base class for our custom environment (the \texttt{apapl.Environment} class is fully functional, contrary to the \texttt{eis.EIDefaultImpl} class). Furthermore, the generation of the \texttt{MANIFEST.MF} file and the exhaustive inclusion of dependencies in the environment \texttt{.jar}-file were not straightforward since special export mechanisms and build path settings had to be used. 

\subsection{Changes to Design}
Since our negotiation algorithm was slightly underspecified in the original design, we reused the algorithm from our Jason implementation: If several partners compete for one product, the seller will always make a new offer to the partner with the lowest previous offer (and the other way round). Both buyers and sellers move twenty percent closer to their respective minimal/maximal price with each offer, until either the difference between two offers becomes less than 10 cent, or their own next offer would be worse than the partner's last offer. When one of these cases is reached, they accept the incoming offer if it is within their price limits and reject it otherwise.

\section{Notes}
The participants are specified as agents during system startup. They are given paths to initialization files from which they read their requested and offered items. This data is then used to set up buying and selling goals. The system of agents can be run through opening the \texttt{electronicmarket.mas} file in the 2APL platform and then starting execution.

The execution of the negotiation process is very verbose: every negotiation initiation, received/accepted/rejected proposal as well as the end of a trade is logged to the console. It is thus possible to track all communication between agents during negotiation. The results of negotiations (successful or not) are printed with the final price. For each additional message (like registering offers and requests), an output line is produced as well.

\end{document}
