\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\headsep1cm
\parindent0cm
\usepackage{amssymb, amstext, amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{graphicx}

\lhead{\textbf{Electronic Market - Jason Implementation}}
\rhead{(Submission: 21.03.2013)}

\cfoot{}
\lfoot{Robert Schmidtke - F121550, Marco Eilers - F121763}
\rfoot{\thepage\ of \pageref{LastPage}}
\pagestyle{fancy}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parskip}{4pt}

\begin{document}

\title{Multi-Agent Programming\\Assignment 3: Electronic Market - Jason Implementation}
\author{Robert Schmidtke - F121550, Marco Eilers - F121763}

\maketitle
\newpage

\section{Translation of Design into Implementation}
Since our negotiation algorithm was slightly underspecified in the original design, we reused the algorithm from our JADE implementation: If several partners compete for one product, the seller will always make a new offer to the partner with the lowest previous offer (and the other way round). Both buyers and sellers move twenty percent closer to their respective minimal/maximal price with each offer, until either the difference between two offers becomes less than 10 cent, or their own next offer would be worse than the partner's last offer. When one of these cases is reached, they accept the incoming offer if it is within their price limits and reject it otherwise.

\subsection{Data Structures}
For the traders we had to translate their knowledge about all ongoing negotiations into beliefs. The most important ones are the following:
\begin{itemize}
  \item \texttt{lastPrice(Product,Partner,Price)} The last price an agent has offered to a partner in the negotiation about a specific product.
  \item \texttt{waitingFor(Product,Partner)} An agent should never make an offer for a specific product while it has not received a response to another offer it made for that product to a different trader, since this might result in it selling (or buying) the product twice if both offers are accepted. \texttt{waitingFor} is used to remember the fact that an agent is still waiting for a response from a specific partner concerning a specific product. If an agent is not waiting for anyone, \texttt{Partner} is \texttt{null}.
 \item \texttt{respondTo(Product,List)} The fact that agents wait for responses means that all offers must eventually get a response, since otherwise an agent might just stop all negotiations for a product. \texttt{respondTo} keeps track of a list of partners who all need to get a response concerning a product. Once an offer is accepted, all agents in this list will get a \texttt{reject} message.
\item \texttt{initialSent(Product,Partner)} It is possible that two agents simultaneously send each other an initial offer for a product. Since we want to avoid double negotiations, the buyer will ignore the incoming initial offer if it has already sent one itself. To keep track of this information, \texttt{initialSent} is used, which denotes that an agent has sent out an initial offer for a product to a partner.
\item \texttt{sales(Product,List)} stores a list of partners to who want to buy a product. The equivalent for the buyer is \texttt{negotiations(Product,List)}.
\item \texttt{offers(Product,MinPrice) } Indicates that this trader wants to sell a product for
at least MinPrice. The equivalent for the buyer is \texttt{requests(Product,MaxPrice)}.
\item \texttt{sold(Product)} This product has been sold, requests concerning it will be
rejected. The equivalent for the buyer is \texttt{bought(Product)}.
\end{itemize}

\subsection{Ease of Implementation}
The implementation felt slightly more complicated than the JADE version, mostly because it took some time to get used to Jason's Prolog-like syntax and event-based programming model. One thing that troubled us for some time was Jason's nondeterminism, especially in combination with parallel execution of several plans. The latter caused quite a lot of errors in our earlier inplementations, and the former made it hard or impossible to reproduce them. We eventually solved this problem by marking all plans as \texttt{atomic}, so that once a plan is selected, only this plan will be followed until that plan is finished. Only then can other plans be executed. This solved a lot of problems that occured when incoming offers were processed \emph{while}, for example, initial offers were made.

We also had to make some compromises due to Jason's event based handling of goals, especially the fact that goals are forgotten once a plans to achieve them has been executed. Since, in some cases, we did not want the agent to forget its goals, we made them beliefs instead. One example is the fact that an agent wants to sell a product: This would normally be considered a goal, but since it is possible that buyers only enter the market place at a later time, we cannot allow the agent to forget about this goal once an initial plan has been followed. This is why we introduced the belief \texttt{offers(Product,MinPrice)} instead, which then creates other goals to start a negotiation, but which is still remembered if there are no buyers initially. This is why long-term goals are almost exclusively modelled as beliefs, whereas the steps to achieve these goals are usually modelled as goals.


\subsection{Changes to Design}


\section{Notes}

\end{document}
